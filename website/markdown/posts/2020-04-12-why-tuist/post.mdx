---
layout: post
title: Why Tuist?
categories:
  [
    tuist,
    xcode project generation,
    xcode,
    swift,
    scale,
    ios,
    projects,
    scalability,
  ]
excerpt: Tuist's new version 1.5.0 brings scaffold command, performance improvements and Mint support
author: pepibumur
---

If you are considering the adoption of Tuist,
you might wonder _why_ a project like yours should do such move.
The idea of adding a new tool to your toolbox might sound intimidating ―
it certainly is.
But believe me,
this is one that you won't regret about.
Despite having done our best to convey the idea behind Tuist,
and why it's an important piece when scaling up projects,
I feel we lacked a good summary

## Make your projects consistent

After bootstrapping new projects and targets in Xcode,
it's up to the developers to ensure that projects are consistently configured and structured.
Some developers might see that as something great,
but that comes with some downsides:

- It adds **indirection** for developers when jumping between projects: _How is this project structured compared to this other?_ _Why is this target linking using build settings flags while the other one is using buid phases?_
- Xcode's **indexing and build system** might not work as effectively because it needs to resolve configuration nuances across all the projects.
  Moreover, those nuances might be conflicting, and result in compilation errors.

You might have seen teams solving this problem at the build settings level by extracting them into reusable [Xcode Build Configuration Files](https://nshipster.com/xcconfig/),
but we should not disregard that settings are just a piece of the cake ―
There are also build phases, targets, or schemes, for which Xcode doesn't provide any way to reuse them.
Other teams resort to scripts that run some checks on the projects,
but that results in a poor experience for developers because those checks are not built into their workflows.

Tuist solves this by providing [project description helpers](/docs/usage/helpers/).
All you need to do is to define what types of projects are supported,
and codify them into functions that return templated projects:

```swift
imporrt ProjectDescription

// Projects+Template.swift

extension Project {
  static func featureFramework(name: String) -> Project { /** Initialize project **/ }
  static func iOSApp(name: String) -> Project { /** Initialize project **/ }
}
```

That makes it possible to create a new feature framework that is consistent with the rest.
For instance,
I can create a new Search feature framework by creating a `Search` directory,
and placing the following `Project.swift` file in it:

```swift
import ProjectDescription
import ProjectDescriptionHelpers

let project = Project.featureFramework(name: "Seach")
```

> Note how idiomatic and concise the definition of projects is ― your project is defined in one line.

## Dependencies

## And more yet to come...

The benefit of having a knowledge on your project is that we can provide very streamlined workflows that leverage Apple's building blocks _(e.g. `xcodebuild`, `simctl`)_.
Here are some of the features that we are planning,
and that you'll be able to opt-in easily if you are already using Tuist:

- **Caching:** This is one of the features we are the most excited about building.
  Unlike build systems like [Buck](https://github.com/facebook/buck) or [Bazel](https://bazel.build/),
  which are mostly adopted by large companies that can invest into build systems and tooling,
  we are exploring adding caching at the module level.
  We'll generate projects where only the targets you plan to work on will be generated ―
  the rest will be pre-compiled frameworks and libraries that we'll pull from a remote cache.
  And the beauty of this feature is that you'll be able to opt-in easily if you are already using Tuist.
- **Selective builds:** As projects get larger, building everything on CI is inefficient.
  For that reason we'll combine [Git](https://git-scm.com/) information with your project's dependency graph to determine what needs to be built.
  In plain words, we'll build
- **Selective test runs:**
- **Run apps from the terminal:** As awesome as it sounds,
  you'll have a command,
  `tuist run`,
  to run any app in the selected destination _(e.g. iOS simulator)_.
  A good use case for this feature is trying out an example app from any of the frameworks of the project,
  without having to open Xcode.

## Some final words

At Tuist, we are aminig to help teams be **productive working with projects of any scale**.

We are aware that not all the projects can have a tooling or infrastructure team,
and for that reason we are designing features optimizing for _(almost)_ **zero configuration** on your end.
Instead of having to depend on many tools to do your job _(e.g. project generators, [Fastlane](https://docs.fastlane.tools/), [Rake](https://github.com/ruby/rake), documentation generator)_,
you'll depend on just one that will make your projects the source of truth,
and derive workflows from there.

In a why that's opinionated and to where you are not making a lot of choices

Project generation is necessary to simplify Xcode's intricacies and provide user-oriented workflows,
but it's not our end goal.
